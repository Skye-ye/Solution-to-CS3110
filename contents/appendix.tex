\section*{Appendix. More OCaml}
\addcontentsline{toc}{section}{Appendix. More OCaml}

\problem[Acronym]
Convert a phrase to its acronym.
Techies love their TLA (Three Letter Acronyms)!
Help generate some jargon by writing a program that converts a long name like Portable Network Graphics to its acronym (PNG).
Punctuation is handled as follows: hyphens are word separators (like whitespace); all other punctuation can be removed from the input.

\begin{lstlisting}[language=OCaml]
open Base

let acronym (phrase : string) : string =
  phrase
  |> String.tr ~target:'-' ~replacement:' '
  |> String.filter ~f:(fun c -> Char.is_alpha c || Char.is_whitespace c)
  |> String.split ~on:' '
  |> List.filter ~f:(fun s -> not (String.is_empty s))
  |> List.map ~f:(fun word -> String.get word 0)
  |> String.of_char_list
  |> String.uppercase
\end{lstlisting}

\problem[Allergies]
Given a person's allergy score, determine whether or not they're allergic to a given item, and their full list of allergies.
An allergy test produces a single numeric score which contains the information about all the allergies the person has (that they were tested for).
The list of items (and their value) that were tested are:

\begin{itemize}
  \item eggs (1)
  \item peanuts (2)
  \item shellfish (4)
  \item strawberries (8)
  \item tomatoes (16)
  \item chocolate (32)
  \item pollen (64)
  \item cats (128)
\end{itemize}

\begin{lstlisting}[language=OCaml]
open Base

type allergen = Eggs
              | Peanuts
              | Shellfish
              | Strawberries
              | Tomatoes
              | Chocolate
              | Pollen
              | Cats

let allergen_scores = [(Eggs, 1); (Peanuts, 2); (Shellfish, 4); (Strawberries, 8); (Tomatoes, 16); (Chocolate, 32); (Pollen, 64); (Cats, 128)]

let allergic_to n allergen =
  let allergen_score = List.Assoc.find allergen_scores allergen ~equal:Poly.equal in
  match allergen_score with
  | Some score -> (n land score) <> 0
  | None -> false

let allergies n =
  List.filter_map allergen_scores ~f:(fun (allergen, score) ->
    if (n land score) <> 0 then Some allergen else None)
\end{lstlisting}

\problem[Anagram]
Given a target word and one or more candidate words, your task is to find the candidates that are anagrams of the target.
An anagram is a rearrangement of letters to form a new word: for example \code{"owns"} is an anagram of \code{"snow"}.
A word is \B{not} its own anagram: for example, \code{"stop"} is not an anagram of \code{"stop"}.
The target word and candidate words are made up of one or more ASCII alphabetic characters (\code{A}-\code{Z} and \code{a}-\code{z}).
Lowercase and uppercase characters are equivalent: for example, \code{"PoTS"} is an anagram of \code{"sTOp"}, but \code{"StoP"} is not an anagram of \code{"sTOp"}.
The words you need to find should be taken from the candidate words, using the same letter case.
Given the target \code{"stone"} and the candidate words \code{"stone"}, \code{"tones"}, \code{"banana"}, \code{"tons"}, \code{"notes"}, and \code{"Seton"}, the anagram words you need to find are \code{"tones"}, \code{"notes"}, and \code{"Seton"}.
You must return the anagrams in the same order as they are listed in the candidate words.

\begin{lstlisting}[language=OCaml]
let normalize_word word =
  word
  |> String.to_seq
  |> List.of_seq
  |> List.sort Char.compare
  |> List.to_seq
  |> String.of_seq

let anagrams target candidates =
  let lower_target = String.lowercase_ascii target in
  let sorted_target = normalize_word lower_target in
  
  List.filter (fun candidate ->
    let lower_candidate = String.lowercase_ascii candidate in
    lower_candidate <> lower_target && 
    normalize_word lower_candidate = sorted_target
  ) candidates
\end{lstlisting}

\problem[Binary Search Tree]
Implement a binary search tree.

\begin{lstlisting}[language=OCaml]
type bst = Leaf | Node of int * bst * bst

let empty = Leaf

let value = function
  | Leaf -> Error "Value of empty tree"
  | Node (v, _, _) -> Ok v

let left = function
  | Leaf -> Error "Left of empty tree"
  | Node (_, l, _) -> Ok l

let right = function
  | Leaf -> Error "Right of empty tree"
  | Node (_, _, r) -> Ok r

let rec insert value tree =
  match tree with
  | Leaf -> Node (value, Leaf, Leaf)
  | Node (v, l, r) -> if value <= v then Node (v, insert value l, r) else Node (v, l, insert value r)

let rec to_list = function
  | Leaf -> []
  | Node (v, l, r) -> to_list l @ [v] @ to_list r
\end{lstlisting}

\problem[Bob]
Your task is to determine what Bob will reply to someone when they say something to him or ask him a question.
Bob only ever answers one of five things:

\begin{itemize}
  \item \B{"Sure."}
        This is his response if you ask him a question, such as "How are you?"
        The convention used for questions is that it ends with a question mark.
  \item \B{"Whoa, chill out!"}
        This is his answer if you YELL AT HIM.
        The convention used for yelling is ALL CAPITAL LETTERS.
  \item \B{"Calm down, I know what I'm doing!"}
        This is what he says if you yell a question at him.
  \item \B{"Fine. Be that way!"}
        This is how he responds to silence.
        The convention used for silence is nothing, or various combinations of whitespace characters.
  \item \B{"Whatever."}
        This is what he answers to anything else.
\end{itemize}

\begin{lstlisting}[language=OCaml]
let is_silence phrase =
  String.trim phrase = ""

let is_question phrase =
  let trimmed = String.trim phrase in
  if String.length trimmed = 0 then false
  else String.ends_with ~suffix:"?" trimmed

let has_letters phrase =
  String.exists (fun c -> (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) phrase

let is_yelling phrase =
  has_letters phrase && String.uppercase_ascii phrase = phrase

let response_for phrase =
  let question = is_question phrase in
  let yelling = is_yelling phrase in
  let silence = is_silence phrase in

  if yelling && question then
    "Calm down, I know what I'm doing!"
  else if yelling then
    "Whoa, chill out!"
  else if question then
    "Sure."
  else if silence then
    "Fine. Be that way!"
  else
    "Whatever."
\end{lstlisting}

\problem[Difference of Squares]
Find the difference between the square of the sum and the sum of the squares of the first N natural numbers.

\begin{lstlisting}[language=OCaml]
let square_of_sum n = 
    let sum = List.fold_left (+) 0 (List.init n (fun x -> x + 1)) in
    sum * sum

let sum_of_squares n =
    List.fold_left (+) 0 (List.init n (fun x -> (x + 1) * (x + 1)))

let difference_of_squares n =
    abs (square_of_sum n - sum_of_squares n)
\end{lstlisting}

\problem[Eliud's Eggs]
Your friend Eliud inherited a farm from her grandma Tigist.
Her granny was an inventor and had a tendency to build things in an overly complicated manner.
The chicken coop has a digital display showing an encoded number representing the positions of all eggs that could be picked up.
Eliud is asking you to write a program that shows the actual number of eggs in the coop.
The position information encoding is calculated as follows:

\begin{itemize}
  \item Scan the potential egg-laying spots and mark down a \code{1} for an existing egg or a \code{0} for an empty spot.
  \item Convert the number from binary to decimal.
  \item Show the result on the display.
\end{itemize}

\begin{lstlisting}[language=OCaml]
let egg_count number =
  let rec egg_count_helper n acc =
    if n = 0 then acc
    else egg_count_helper (n / 2) (acc + n mod 2)
  in
  egg_count_helper number 0
\end{lstlisting}

\problem[ETL]
Your task is to change the data format of letters and their point values in the game.
Currently, letters are stored in groups based on their score, in a one-to-many mapping.
\begin{itemize}
  \item 1 point: "A", "E", "I", "O", "U", "L", "N", "R", "S", "T",
  \item 2 points: "D", "G",
  \item 3 points: "B", "C", "M", "P",
  \item 4 points: "F", "H", "V", "W", "Y",
  \item 5 points: "K",
  \item 8 points: "J", "X",
  \item 10 points: "Q", "Z",
\end{itemize}
This needs to be changed to store each individual letter with its score in a one-to-one mapping.
\begin{itemize}
  \item "a" is worth 1 point.
  \item "b" is worth 3 points.
  \item "c" is worth 3 points.
  \item "d" is worth 2 points.
  \item etc.
\end{itemize}

\begin{lstlisting}[language=OCaml]
let transform (legacy_data: (int * char list) list) : (char * int) list =
  let flat_list =
    List.concat_map (fun (score, letters) ->
      List.map (fun letter ->
        let lower_char = Char.lowercase_ascii letter in
        (lower_char, score)
      ) letters
    ) legacy_data
  in
  List.sort (fun (char1, _) (char2, _) ->
    Char.compare char1 char2
  ) flat_list
\end{lstlisting}

\problem[Grade School]
Given students' names along with the grade they are in, create a roster for the school.
In the end, you should be able to:
\begin{itemize}
  \item Add a student's name to the roster for a grade:
        \begin{itemize}
          \item ``Add Jim to grade 2.''
          \item ``OK.''
        \end{itemize}
  \item Get a list of all students enrolled in a grade:
        \begin{itemize}
          \item ``Which students are in grade 2?''
          \item ``We've only got Jim right now.''
        \end{itemize}
  \item Get a sorted list of all students in all grades.
        Grades should be sorted as 1, 2, 3, etc., and students within a grade should be sorted alphabetically by name.
        \begin{itemize}
          \item ``Who is enrolled in school right now?''
          \item ``Let me think.
                We have Anna, Barb, and Charlie in grade 1, Alex, Peter, and Zoe in grade 2, and Jim in grade 5.
                So the answer is: Anna, Barb, Charlie, Alex, Peter, Zoe, and Jim.''
        \end{itemize}
\end{itemize}
Note that all our students only have one name (it's a small town, what do you want?), and each student cannot be added more than once to a grade or the roster.
If a test attempts to add the same student more than once, your implementation should indicate that this is incorrect.

\begin{lstlisting}[language=OCaml]
open Base

module Int_map = Map.M(Int)
type school = string list Int_map.t

let empty_school = Map.empty (module Int)

let add name grade_num school =
  Map.change school grade_num ~f:(fun maybe_students ->
    let students = Option.value maybe_students ~default:[] in
    let new_students = name :: students in
    Some (List.sort new_students ~compare:String.compare)
  )

let grade g school =
  Map.find school g |> Option.value ~default:[]

let sorted school =
  Map.map school ~f:(List.sort ~compare:String.compare)

let roster school =
  List.concat (Map.data school)
\end{lstlisting}

\problem[Hamming]
Calculate the Hamming distance between two DNA strands.
We read DNA using the letters C, A, G and T.
Two strands might look like this:
\begin{verbatim}
GAGCCTACTAACGGGAT
CATCGTAATGACGGCCT
^ ^ ^  ^ ^    ^^
\end{verbatim}
They have 7 differences, and therefore the Hamming distance is 7.

\begin{lstlisting}[language=OCaml]
type nucleotide = A | C | G | T

let hamming_distance (seq1: nucleotide list) (seq2: nucleotide list) =
  if List.length seq1 == 0 && List.length seq2 == 0 then Ok 0
  else if List.length seq1 == 0 then Error "left strand must not be empty"
  else if List.length seq2 == 0 then Error "right strand must not be empty"
  else if List.length seq1 <> List.length seq2 then Error "left and right strands must be of equal length"
  else
  let rec hamming_distance_helper seq1 seq2 acc = 
    match seq1, seq2 with
    | [], [] -> Ok acc
    | [], _ | _, [] -> Error "left and right strands must be of equal length"
    | x::xs, y::ys -> hamming_distance_helper xs ys (acc + if x = y then 0 else 1)
  in
  hamming_distance_helper seq1 seq2 0
\end{lstlisting}

\problem[Isogram]
Determine if a word or phrase is an isogram.
An isogram (also known as a ``non-pattern word'') is a word or phrase without a repeating letter, however spaces and hyphens are allowed to appear multiple times.
Examples of isograms:

\begin{itemize}
  \item lumberjacks
  \item background
  \item downstream
  \item six-year-old
\end{itemize}
The word \code{"isograms"}, however, is not an isogram, because the \code{s} repeats.

\begin{lstlisting}[language=OCaml]
open Base

let is_isogram word =
    let rec is_isogram_helper set chars =
        match chars with
        | [] -> true
        | c :: rest when Char.is_alpha c ->
            let c_lower = Char.lowercase c in
            if Set.mem set c_lower then false
            else is_isogram_helper (Set.add set c_lower) rest
        | _ :: rest -> is_isogram_helper set rest
    in
    let chars = String.to_list word in
    is_isogram_helper (Set.empty (module Char)) chars
\end{lstlisting}

\problem[Leap]
Determine whether a given year is a leap year.

\begin{lstlisting}[language=OCaml]
let leap_year year =
    if year mod 4 = 0 then
        if year mod 100 = 0 then
            if year mod 400 = 0 then
                true
            else
                false
        else
            true
    else
        false
\end{lstlisting}

\problem[nucleotide Count]
Given a string representing a DNA sequence, count how many of each nucleotide is present.
If the string contains characters that aren't A, C, G, or T then it is invalid and you should signal an error.
For example:
\begin{verbatim}
"GATTACA" -> `A': 3, `C': 1, `G': 1, `T': 2
"INVALID" -> error
\end{verbatim}

\begin{lstlisting}[language=OCaml]
open Base

let empty = Map.empty (module Char)

let dna_set = Set.of_list (module Char) ['A'; 'C'; 'G'; 'T']

let count_nucleotide s c =
  if Set.mem dna_set c then
    let invalid_char = String.to_list s |> List.find ~f:(fun ch -> not (Set.mem dna_set ch)) in
    match invalid_char with
    | Some invalid -> Error invalid
    | None -> Ok (String.count s ~f:(Char.equal c))
  else
    Error c

let count_nucleotides s =
  let rec count_nucleotides_helper s acc =
    match s with
    | [] -> Ok acc
    | c::cs -> begin
      if Set.mem dna_set c then
        let current_count = Map.find acc c |> Option.value ~default:0 in
        count_nucleotides_helper cs (Map.set acc ~key:c ~data:(current_count + 1))
        else
          Error c
    end
  in
  count_nucleotides_helper (String.to_list s) empty
\end{lstlisting}

\problem[Pangram]
Your task is to figure out if a sentence is a pangram.
A pangram is a sentence using every letter of the alphabet at least once.
It is case insensitive, so it doesn't matter if a letter is lower-case (e.g. \code{k}) or upper-case (e.g. \code{K}).
For this exercise, a sentence is a pangram if it contains each of the 26 letters in the English alphabet.

\begin{lstlisting}[language=OCaml]
open Base

let is_pangram sentence =
  sentence
  |> String.lowercase
  |> String.to_list
  |> List.filter ~f:Char.is_alpha
  |> List.dedup_and_sort ~compare:Char.compare
  |> List.length
  |> (=) 26
\end{lstlisting}

\problem[Raindrops]
Your task is to convert a number into its corresponding raindrop sounds.
If a given number:

\begin{itemize}
  \item is divisible by 3, add \code{"Pling"} to the result.
  \item is divisible by 5, add \code{"Plang"} to the result.
  \item is divisible by 7, add \code{"Plong"} to the result.
  \item \B{is not} divisible by 3, 5, or 7, the result should be the number as a string.
\end{itemize}

\begin{lstlisting}[language=OCaml]
let raindrop n =
	let res = ref "" in
	if n mod 3 = 0 then res := !res ^ "Pling";
	if n mod 5 = 0 then res := !res ^ "Plang";
	if n mod 7 = 0 then res := !res ^ "Plong";
	if !res = "" then res := !res ^ string_of_int n;
	!res
\end{lstlisting}

\problem[Reverse String]
Reverse a given string.

\begin{lstlisting}[language=OCaml]
open Base

let reverse_string s =
  String.to_list s 
  |> List.rev 
  |> String.of_char_list
\end{lstlisting}

\problem[RNA Transcription]
Determine the RNA complement of a given DNA sequence.

\begin{lstlisting}[language=OCaml]
type dna = [ `A | `C | `G | `T ]
type rna = [ `A | `C | `G | `U ]

let to_rna seq =
  List.map (function
  	| `A -> `U
    | `C -> `G
    | `G -> `C
    | `T -> `A
  ) seq
\end{lstlisting}

\problem[Sieve]
Your task is to create a program that implements the Sieve of Eratosthenes algorithm to find all prime numbers less than or equal to a given number.

\begin{lstlisting}[language=OCaml]
let primes limit =
  if limit < 2 then []
  else
    let sieve = Array.make (limit + 1) true in
    sieve.(0) <- false;
    sieve.(1) <- false;

    for p = 2 to int_of_float (sqrt (float_of_int limit)) do
      if sieve.(p) then
        let i = ref (p * p) in
        while !i <= limit do
          sieve.(!i) <- false;
          i := !i + p
        done
    done;

    let result = ref [] in
    for i = limit downto 2 do
      if sieve.(i) then
        result := i :: !result
    done;
    !result
\end{lstlisting}

\problem[Space Age]
Given an age in seconds, calculate how old someone would be on a planet in our Solar System.
One Earth year equals 365.25 Earth days, or 31,557,600 seconds.
If you were told someone was 1,000,000,000 seconds old, their age would be 31.69 Earth-years.
For the other planets, you have to account for their orbital period in Earth Years:

\begin{center}
  \begin{tabular}{l|l}
    Planet  & Orbital period in Earth Years \\
    \hline
    Mercury & 0.2408467                     \\
    Venus   & 0.61519726                    \\
    Earth   & 1.0                           \\
    Mars    & 1.8808158                     \\
    Jupiter & 11.862615                     \\
    Saturn  & 29.447498                     \\
    Uranus  & 84.016846                     \\
    Neptune & 164.79132                     \\
  \end{tabular}
\end{center}

\begin{lstlisting}[language=OCaml]
type planet = Mercury | Venus | Earth | Mars
            | Jupiter | Saturn | Neptune | Uranus

let orbital_period_in_earth_years = function
  | Mercury -> 0.2408467
  | Venus   -> 0.61519726
  | Earth   -> 1.0
  | Mars    -> 1.8808158
  | Jupiter -> 11.862615
  | Saturn  -> 29.447498
  | Uranus  -> 84.016846
  | Neptune -> 164.79132

let age_on (p : planet) (seconds : int) : float =
  let earth_year_in_seconds = 31_557_600.0 in
  
  let age_in_earth_years = float_of_int seconds /. earth_year_in_seconds in
  
  let planet_orbital_period = orbital_period_in_earth_years p in
  
  age_in_earth_years /. planet_orbital_period

\end{lstlisting}

\problem[Triangle]
Determine if a triangle is equilateral, isosceles, or scalene.

\begin{itemize}
  \item An \code{equilateral} triangle has all three sides the same length.
  \item An \code{isosceles} triangle has at least two sides the same length.
  \item A \code{scalene} triangle has all sides of different lengths.
\end{itemize}

\begin{lstlisting}[language=OCaml]
let is_triangle a b c =
	a + b > c && a + c > b && b + c > a

let is_equilateral a b c =
	is_triangle a b c && a = b && b = c

let is_isosceles a b c =
	is_triangle a b c && (a = b || b = c || a = c)

let is_scalene a b c =
	is_triangle a b c && a <> b && b <> c && a <> c
\end{lstlisting}

